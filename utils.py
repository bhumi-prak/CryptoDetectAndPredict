import os
import smtplib
import logging
from email.mime.text import MIMEText
from email.mime.multipart import MIMEMultipart
from datetime import datetime, timedelta
from dataset_generator import generate_dataset  # make sure this file exists
from model_trainer import train_model           # make sure this file exists
from sklearn.metrics import accuracy_score
import joblib
import hashlib
import json

class EmailNotifier:
    def __init__(self):
        self.smtp_server = os.environ.get('SMTP_SERVER', 'smtp.gmail.com')
        self.smtp_port = int(os.environ.get('SMTP_PORT', '587'))
        self.smtp_username = os.environ.get('SMTP_USERNAME', '')
        self.smtp_password = os.environ.get('SMTP_PASSWORD', '')
        self.from_email = os.environ.get('FROM_EMAIL', self.smtp_username)
    
    def send_threat_alert(self, user_email, threat_details):
        """Send threat detection alert email"""
        try:
            if not self.smtp_username or not self.smtp_password:
                logging.warning("Email credentials not configured")
                return False
            
            subject = f"ðŸš¨ Ransomware Threat Detected - {threat_details.get('threat_level', 'Unknown').upper()}"
            
            # Create email content
            html_content = f"""
            <html>
            <body style="font-family: Arial, sans-serif; color: #333;">
                <div style="background-color: #f8f9fa; padding: 20px; border-radius: 8px;">
                    <h2 style="color: #dc3545;">ðŸš¨ Threat Detection Alert</h2>
                    
                    <div style="background-color: white; padding: 15px; border-radius: 5px; margin: 10px 0;">
                        <h3>Threat Details:</h3>
                        <ul>
                            <li><strong>File:</strong> {threat_details.get('file_path', 'Unknown')}</li>
                            <li><strong>Threat Level:</strong> <span style="color: #dc3545;">{threat_details.get('threat_level', 'Unknown').upper()}</span></li>
                            <li><strong>Detection Time:</strong> {datetime.utcnow().strftime('%Y-%m-%d %H:%M:%S UTC')}</li>
                            <li><strong>File Hash:</strong> {threat_details.get('file_hash', 'N/A')}</li>
                            <li><strong>File Size:</strong> {threat_details.get('file_size', 'N/A')} bytes</li>
                        </ul>
                    </div>
                    
                    <div style="background-color: #fff3cd; padding: 15px; border-radius: 5px; margin: 10px 0; border-left: 4px solid #ffc107;">
                        <h3>Recommended Actions:</h3>
                        <ul>
                            <li>Immediately disconnect from the internet if possible</li>
                            <li>Do not open or execute the detected file</li>
                            <li>Run a full system scan</li>
                            <li>Consider quarantining the threat</li>
                            <li>Back up important files if not already done</li>
                        </ul>
                    </div>
                    
                    <p style="color: #666; font-size: 12px; margin-top: 20px;">
                        This alert was generated by the Ransomware Detection System.<br>
                        If you believe this is a false positive, please review the file manually.
                    </p>
                </div>
            </body>
            </html>
            """
            
            # Create message
            msg = MIMEMultipart('alternative')
            msg['Subject'] = subject
            msg['From'] = self.from_email
            msg['To'] = user_email
            
            # Attach HTML content
            html_part = MIMEText(html_content, 'html')
            msg.attach(html_part)
            
            # Send email
            with smtplib.SMTP(self.smtp_server, self.smtp_port) as server:
                server.starttls()
                server.login(self.smtp_username, self.smtp_password)
                server.send_message(msg)
            
            logging.info(f"Threat alert email sent to {user_email}")
            return True
            
        except Exception as e:
            logging.error(f"Failed to send threat alert email: {e}")
            return False
    
    def send_scan_report(self, user_email, scan_results):
        """Send scan completion report"""
        try:
            if not self.smtp_username or not self.smtp_password:
                logging.warning("Email credentials not configured")
                return False
            
            subject = f"Scan Complete - {scan_results.get('threats_found', 0)} threats found"
            
            html_content = f"""
            <html>
            <body style="font-family: Arial, sans-serif; color: #333;">
                <div style="background-color: #f8f9fa; padding: 20px; border-radius: 8px;">
                    <h2 style="color: #28a745;">âœ… Scan Completed</h2>
                    
                    <div style="background-color: white; padding: 15px; border-radius: 5px; margin: 10px 0;">
                        <h3>Scan Summary:</h3>
                        <ul>
                            <li><strong>Scan Type:</strong> {scan_results.get('scan_type', 'Unknown')}</li>
                            <li><strong>Files Scanned:</strong> {scan_results.get('files_scanned', 0):,}</li>
                            <li><strong>Threats Found:</strong> {scan_results.get('threats_found', 0)}</li>
                            <li><strong>Scan Duration:</strong> {scan_results.get('scan_duration', 0):.2f} seconds</li>
                            <li><strong>Completion Time:</strong> {datetime.utcnow().strftime('%Y-%m-%d %H:%M:%S UTC')}</li>
                        </ul>
                    </div>
                    
                    <p>Please log in to your dashboard to view detailed results and take action on any detected threats.</p>
                </div>
            </body>
            </html>
            """
            
            # Create and send message
            msg = MIMEMultipart('alternative')
            msg['Subject'] = subject
            msg['From'] = self.from_email
            msg['To'] = user_email
            
            html_part = MIMEText(html_content, 'html')
            msg.attach(html_part)
            
            with smtplib.SMTP(self.smtp_server, self.smtp_port) as server:
                server.starttls()
                server.login(self.smtp_username, self.smtp_password)
                server.send_message(msg)
            
            logging.info(f"Scan report email sent to {user_email}")
            return True
            
        except Exception as e:
            logging.error(f"Failed to send scan report email: {e}")
            return False

class SecurityUtils:
    @staticmethod
    def generate_secure_filename(original_filename):
        """Generate a secure filename for quarantine/backup"""
        timestamp = datetime.utcnow().strftime('%Y%m%d_%H%M%S')
        file_hash = hashlib.md5(original_filename.encode()).hexdigest()[:8]
        return f"{timestamp}_{file_hash}_{original_filename}"
    
    @staticmethod
    def validate_file_path(file_path):
        """Validate file path to prevent directory traversal"""
        # Resolve the path to get absolute path
        abs_path = os.path.abspath(file_path)
        
        # Check if path exists
        if not os.path.exists(abs_path):
            return False, "File does not exist"
        
        # Check if path is within allowed directories
        allowed_prefixes = [
            os.path.expanduser('~'),  # User home directory
            '/tmp',
            '/var/tmp'
        ]
        
        is_allowed = any(abs_path.startswith(prefix) for prefix in allowed_prefixes)
        if not is_allowed:
            return False, "File path not in allowed directories"
        
        return True, "Valid path"
    
    @staticmethod
    def calculate_risk_score(threat_indicators):
        """Calculate overall risk score based on various indicators"""
        score = 0
        max_score = 100
        
        # File entropy (0-30 points)
        entropy = threat_indicators.get('entropy', 0)
        if entropy > 7.5:
            score += 30
        elif entropy > 6.5:
            score += 20
        elif entropy > 5.5:
            score += 10
        
        # Suspicious filename (0-25 points)
        if threat_indicators.get('suspicious_filename', False):
            score += 25
        
        # Executable type (0-20 points)
        if threat_indicators.get('is_executable', False):
            score += 20
        
        # File size anomalies (0-15 points)
        file_size = threat_indicators.get('file_size', 0)
        if file_size == 0:  # Zero-byte files
            score += 15
        elif file_size > 100 * 1024 * 1024:  # Very large files
            score += 10
        
        # Recent creation/modification (0-10 points)
        if threat_indicators.get('recently_modified', False):
            score += 10
        
        return min(score, max_score)
    
    @staticmethod
    def format_file_size(size_bytes):
        """Format file size in human-readable format"""
        if size_bytes == 0:
            return "0 B"
        
        size_names = ["B", "KB", "MB", "GB", "TB"]
        import math
        i = int(math.floor(math.log(size_bytes, 1024)))
        p = math.pow(1024, i)
        s = round(size_bytes / p, 2)
        return f"{s} {size_names[i]}"
    
    @staticmethod
    def get_threat_color(threat_level):
        """Get color code for threat level"""
        colors = {
            'low': '#28a745',      # Green
            'medium': '#ffc107',   # Yellow
            'high': '#fd7e14',     # Orange
            'critical': '#dc3545'  # Red
        }
        return colors.get(threat_level.lower(), '#6c757d')  # Default gray

class ConfigManager:
    def __init__(self, config_file='config.json'):
        self.config_file = config_file
        self.default_config = {
            'scan_settings': {
                'max_file_size': 100 * 1024 * 1024,  # 100MB
                'scan_timeout': 3600,  # 1 hour
                'entropy_threshold': 7.5,
                'excluded_extensions': ['.tmp', '.log', '.cache'],
                'excluded_directories': ['.git', '__pycache__', 'node_modules']
            },
            'alert_settings': {
                'email_enabled': True,
                'min_threat_level': 'medium',
                'alert_cooldown': 300  # 5 minutes
            },
            'quarantine_settings': {
                'auto_quarantine': False,
                'backup_before_quarantine': True,
                'quarantine_retention_days': 30
            },
            'monitoring_settings': {
                'realtime_monitoring': True,
                'cpu_threshold': 90,
                'memory_threshold': 85,
                'disk_threshold': 95
            }
        }
        self.config = self.load_config()
    
    def load_config(self):
        """Load configuration from file"""
        try:
            if os.path.exists(self.config_file):
                with open(self.config_file, 'r') as f:
                    config = json.load(f)
                # Merge with default config
                return {**self.default_config, **config}
            else:
                return self.default_config.copy()
        except Exception as e:
            logging.error(f"Failed to load config: {e}")
            return self.default_config.copy()
    
    def save_config(self):
        """Save configuration to file"""
        try:
            with open(self.config_file, 'w') as f:
                json.dump(self.config, f, indent=2)
            logging.info("Configuration saved")
        except Exception as e:
            logging.error(f"Failed to save config: {e}")
    
    def get(self, key, default=None):
        """Get configuration value"""
        keys = key.split('.')
        value = self.config
        for k in keys:
            value = value.get(k, {})
        return value if value != {} else default
    
    def set(self, key, value):
        """Set configuration value"""
        keys = key.split('.')
        config = self.config
        for k in keys[:-1]:
            if k not in config:
                config[k] = {}
            config = config[k]
        config[keys[-1]] = value
        self.save_config()

# Global instances
email_notifier = EmailNotifier()
config_manager = ConfigManager()

import sqlite3

def get_threats_from_db():
    """Fetch all threats from the database"""
    try:
        conn = sqlite3.connect("database.db")
        cursor = conn.cursor()

        cursor.execute("SELECT id, file_path, threat_level, detected_at FROM threats")
        rows = cursor.fetchall()
        conn.close()

        threats = []
        for r in rows:
            threats.append({
                "id": r[0],
                "file_path": r[1],
                "threat_level": r[2],
                "detected_at": r[3]
            })
        return threats
    except Exception as e:
        logging.error(f"Failed to fetch threats: {e}")
        return []

MODEL_PATH = "model.pkl"  # adjust if your model file is stored elsewhere

def retrain_model():
    """
    Generates dataset, retrains model, evaluates it,
    and saves the trained model to disk.
    Returns training and testing accuracy.
    """
    print("ðŸ”„ Starting dataset generation...")
    X_train, X_test, y_train, y_test = generate_dataset()

    print("ðŸ“Š Training model...")
    model = train_model(X_train, y_train)

    # Evaluate on train/test sets
    train_acc = accuracy_score(y_train, model.predict(X_train))
    test_acc = accuracy_score(y_test, model.predict(X_test))

    # Save the model
    joblib.dump(model, MODEL_PATH)
    print(f"âœ… Model saved to {MODEL_PATH}")
    print(f"Train Accuracy: {train_acc:.4f}, Test Accuracy: {test_acc:.4f}")

    return train_acc, test_acc

